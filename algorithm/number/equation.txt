k * C(n, k) = n * C(n - 1, k - 1)
// 此公式可以用dp了， nb

C(n, 0) + C(n, 1) + C(n, 2) +... + C(n, n) = 2^n
解释：每一个组合都一一对应0～2^n中的一个数 （转换成0,1序列后）

1 * C(n, 1) + 2 * C(n, 2) + ... + n * C(n, n) = 
n * C(n - 1, 0) + n * C(n - 1, 1) + ... + n C(n - 1, n - 1) =
n * 2^(n - 1)





// http://buptdtt.blog.51cto.com/2369962/832586
Catalan数:
h(0) = 1;
h(1) = 1;
n >=2
h(n) = h(0) * h(n - 1) + h(1) * h(n - 2) + ... + h(n - 1) * h(0)
     = C(2* n, n) / (n + 1)

// 二叉树有多少种? 根据根节点分类，直接套用上述公式

// 矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？
// Note: (a1 * a2) 这种加括号法不是对积，此时只有（a1） * (a2) 一种加括号的方法

h(1) * h(n - 1) + h(2) * h(n - 2) + ...+ h(n - 1) * h(1)
<==>
h'(0) * h'(n - 2) + h'(1) * h'(n - 1) + .... + h'(n - 2) * h'(0)
= h(n - 1)

// 一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?
// 令：1进栈，2进栈，2出栈，1出栈 对应的序列为1，2，2‘，1’（序列长度为4）
// 第0个数字肯定是进栈的数，这个数相应的出栈的数一定是第2i+1个数。因为如果
// 是2i，那么中间包含了奇数个数，这奇数个肯定无法构成进栈出栈序列。

// 此问题 和 下面问题等价

// n对括号有多少种匹配方式？
// 左括号代表入栈，右括号代表出栈

// 在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数？ / 圆桌周围有 2n个人，他们两两握手，但没有交叉的方案数?
// (此问题如果判断当前连线是否有交点，前提是连线可以走圈内也可以走圈外，使用2-sat算法)
// 
// 有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，
// 剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？
// 如果不区分人身份的不同的话结果为h（n）, 否则为 h(n) * n! * n!


// n*n的方格地图中，从左下角到右上角，不跨越对角线的路径数,且只能向右或上移动?
// 一定要走2*n步，由于不能跨越对角线，向右可以看作入栈，向上走可以看作出栈
// 如果可以跨越对角线结果为C(2*n, n)（从2*n步中随意选择出n个向上走的步）
f(n) 表示序列个数为n的情况下其不同进栈出栈的数目，则原问题的结果显然为f(2*n)

分析原问题：
f(2*n) = f(0) * f(2n - 2) + f(2) * f(2n - 4) + ... + f(2n - 2) * f(0)

f(0)可以看作：第1个元素进栈后马上出栈，1与1‘之间包含的序列长度为0，这个序列的不同的进栈出栈次序显然为f(0), 剩余元素组成的序列长度为2n - 2 即 f(2n - 2)
f(2)看作：1，2， 2‘ 1’ ，即1，与 1‘之间序列的长度为2
...

上式等价于
f(2*n) = f(0) * f(n - 1) + f(1) * f(n - 2) + ... + f(n-1) * f(0) = h(n) (catalan数)


// 求一个凸多边形区域划分成三角形区域的方法数？
// 思路：以凸多边形的一边为基，设这条边的2个顶点为A和B。从剩余顶点中选1个，可以将凸多边形分成三个部分，
// 中间是一个三角形，左右两边分别是两个凸多边形，然后求解左右两个凸多边形。

f(n) : 表示n个顶点的图多边形的三角区域数

根据第一次划分的情况分类

f(n) = f(2) + f(n - 1) + f(3) + f(n - 2) + ... + f(n - 1)* f(2)
     = f(0) + f(n - 3) + f(1) + f(n - 4) + ..
     = h(n - 2)





第二类stirling数
// 把从1到p标号的p个球放到k个无区别的盒子里，要求每个盒子里至少有一个小球，问不同的放法？(p >= k)

S(p, k) = S(p - 1, k - 1) + k *S(p - 1, k)
          第k个求单独在一个盒子   第k个球所在的盒子还有其它球

S(p, k) = 1 when p == k || k == 1
S(p, k) = 0 when k == 0


S(p, 2) = (2 ^ p - 2) / 2
S(p, p - 1) = C(n, 2)



// bell数
// Bn是基数为n的集合的划分方法的数目。集合S的一个划分是定义为S的两两不相交的非空子集的族，它们的并是S。
// 例如B3 = 5因为3个元素的集合{a, b, c}有5种不同的划分方法：
// {{a}, {b}, {c}}
// {{a}, {b, c}}
// {{b}, {a, c}}
// {{c}, {a, b}}
// {{a, b, c}};
// 
// B(n + 1) = sum[C(n, k) * B(k)] (0 <= k <= n)
// 根据最后一个数所在的集合分类
// 最后一个数(n + 1)所在的集合含有一个数：C(n, n) * B(n)
// 最后一个数(n + 1)所在的集合含有2个数：C(n, n - 1) * B(n - 1)
// 最后一个数(n + 1)所在的集合含有3个数：C(n, n - 2) * B(n - 2)


// bell数与第二类stirling数的关系
// B(n) = sum(S(n, k))  (1<=k<=n)
// 计算bell数，先计算第二类stirling数，再计算bell数比较方便


// 第一类stirling数
// 将p个物体排成k个非空循环排列的方法数？
// （p个人排成k个非空圈圈的方法数）
// 例如：S1(4, 2)
// 1. {A,B},{C,D}
// 2. {A,C},{B,D}
// 3. {A,D},{B,C}
// 4. {A},{B,C,D}
// 5. {A},{B,D,C}
// 6. {B},{A,C,D}
// 7. {B},{A,D,C}
// 9. {C},{A,B,D}
// 10.{C},{A,D,B}
// 11.{D},{A,B,C}
// 12.{D},{A,C,B

// S1(p, k) = S1(p - 1, k - 1) + (p - 1) * S1(p - 1, k)
             最后一个单独成圈   最后一个数和其它数成圈/相当与p-1个数排好圈后插入其中一个位置，共有p - 1个位置可供插入
   S1(p, 0) = 0
   S1(1, 1) = 1

