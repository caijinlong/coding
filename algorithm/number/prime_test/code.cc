// Copyright 2013 Jike Inc. All Rights Reserved.
// Author: Liqiang Guo(guoliqiang@jike.com)
// I just want to GH to hss~
// Date  : 2013-10-28 02:13:54
// File  : code.cc
// Brief :
/*
 *  Fermat(费尔马)小定理 http://book.51cto.com/art/200812/102434.htm
 * 1. 第一种形式
 * 第一种形式认为如果p是一个素数，且a是一个不能被p整除的整数，那么 。
 * 2. 第二种形式
 * 第二种形式取消了对a的限制条件。如果p是素数，a为整数，那么 。
 * 3.
 * 如果p是素数，a是小于p的正整数，那么a^(p-1) mod p = 1。
 *
 *
 * Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步，建立了传说中的Miller-Rabin素性测试算法。
 * 新的测试基于下面的定理：如果p是素数，x是小于p的正整数，且x^2 mod p = 1，那么要么x=1，要么x=p-1。这是显然的，
 * 因为x^2 mod p = 1相当于p能整除x^2-1，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是x-1能被p整除(此时x=1)
 * 或x+1能被p整除(此时x=p-1)。
 *
 * http://www.matrix67.com/blog/archives/234
 * http://blog.csdn.net/hanhansoul/article/details/9060203
 * http://www.cnblogs.com/jiaohuang/archive/2010/09/05/1818663.html
 *
 * http://www.cnblogs.com/vongang/archive/2012/03/15/2398626.html
 * */

#include "base/public/common_head.h"

namespace algorithm {

// 快速求解 (a * b) % n
// 例如: b = 1011101 
// 那么a * b mod n = (a * 1000000 mod n + a * 10000 mod n + a * 1000 mod n + a * 100 mod n + a * 1 mod n) mod n 

int MultiMod(int a, int b, int n) {
  int tmp = 0;
  while (b) {
    if (b & 1) tmp = (tmp + a) % n;
    a = (a * 2) % n;
    b >>= 1;
  }
  return tmp;
}

// 快速求解 (a ^ b) % n
// b =110
// (a^b) % n  = (a^(2^2) % n * a^(2^1) % n) %n
int PowMod(int a, int b, int n) {
  int tmp = 1;
  while (b) {
    if (b & 1) tmp = MultiMod(a, tmp, n);
    a = (a * a) % n; // 用快速的
    b >>= 1;
  }
  return tmp;
}
}  // namespace algorithm

/*
 * 费马小定理：
 * 如果p是素数，a是小于p的正整数，那么a^(p-1) mod p = 1。
 *
 * 谈到Fermat小定理，数学历史上有很多误解。很长一段时间里，人们都认为Fermat小定理的逆命题是正确的，
 * 并且有人亲自验证了a=2, p<300的所有情况。国外甚至流传着一种说法，认为中国在孔子时代就证明了这样的定理：
 * 如果n整除2^(n-1)-1，则n就是素数。后来某个英国学者进行考证后才发现那是因为他们翻译中国古文时出了错。
 * 1819年有人发现了Fermat小定理逆命题的第一个反例：虽然2的340次方除以341余1，但341=11*31。后来，
 * 人们又发现了561, 645, 1105等数都表明a=2时Fermat小定理的逆命题不成立。虽然这样的数不多，
 * 但不能忽视它们的存在。于是，人们把所有能整除2^(n-1)-1的合数n叫做伪素数(pseudoprime)，
 * 意思就是告诉人们这个素数是假的。
 *
 * 不满足2^(n-1) mod n = 1的n一定不是素数；如果满足的话则多半是素数。这样，一个比试除法效率更
 * 高的素性判断方法出现了：制作一张伪素数表，记录某个范围内的所有伪素数，那么所有满足2^(n-1) mod n = 1且不
 * 在伪素数表中的n就是素数。之所以这种方法更快，是因为我们可以使用二分法快速计算2^(n-1) mod n 的值
 * ，这在计算机的帮助下变得非常容易；在计算机中也可以用二分查找有序数列、Hash表开散列、构建Trie树等方法使得查找伪素数表效率更高。
 * 有人自然会关心这样一个问题：伪素数的个数到底有多少？换句话说，如果我只计算2^(n-1) mod n的值，事先不准备伪素数表，
 * 那么素性判断出错的概率有多少？研究这个问题是很有价值的，毕竟我们是OIer，不
 * 可能背一个长度上千的常量数组带上考场。统计表明，在前10亿个自然数中共有50847534个素数，
 * 而满足2^(n-1) mod n = 1的合数n有5597个。这样算下来，算法出错的可能性约为0.00011。这个概率太高了，
 * 如果想免去建立伪素数表的工作，我们需要改进素性判断的算法。
 *
 * 最简单的想法就是，我们刚才只考虑了a=2的情况。对于式子a^(n-1) mod n，取不同的a可能导致不同的结果。
 * 一个合数可能在a=2时通过了测试，但a=3时的计算结果却排除了素数的可能。于是，人们扩展了伪素数的定义，称满足a^(n-1) 
 * mod n = 1的合数n叫做以a为底的伪素数(pseudoprime to base a)。前10亿个自然数中同时以2和3为底的伪素数只有1272个，
 * 这个数目不到刚才的1/4。这告诉我们如果同时验证a=2和a=3两种情况，算法出错的概率降到了0.000025。容易想到，
 * 选择用来测试的a越多，算法越准确。通常我们的做法是，随机选择若干个小于待测数的正整数作为底数a进行若干次测试，
 * 只要有一次没有通过测试就立即把这个数扔回合数的世界。这就是Fermat素性测试。
 *
 *  人们自然会想，如果考虑了所有小于n的底数a，出错的概率是否就可以降到0呢？没想到的是，居然就有这样的合数，
它可以通过所有a的测试（这个说法不准确，详见我在地核楼层的回复）。Carmichael第一个发现这样极端的伪素数，
他把它们称作Carmichael数。你一定会以为这样的数一定很大。错。第一个Carmichael数小得惊人，仅仅是一个三位数，561。
前10亿个自然数中Carmichael数也有600个之多。Carmichael数的存在说明，我们还需要继续加强素性判断的算法。

Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步，建立了传说中的Miller-Rabin素性测试算法。
新的测试基于下面的定理：如果p是素数，x是小于p的正整数，且x^2 mod p = 1，那么要么x=1，要么x=p-1。
这是显然的，因为x^2 mod p = 1相当于p能整除x^2-1，也即p能整除(x+1)(x-1)。由于p是素数，
那么只可能是x-1能被p整除(此时x=1)或x+1能被p整除(此时x=p-1)。
Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步，建立了传说中的Miller-Rabin素性测试算法。
新的测试基于下面的定理：如果p是素数，x是小于p的正整数，且x^2 mod p = 1，那么要么x=1，要么x=p-1。
这是显然的，因为x^2 mod p = 1相当于p能整除x^2-1，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是
x-1能被p整除(此时x=1)或x+1能被p整除(此时x=p-1)。
我们下面来演示一下上面的定理如何应用在Fermat素性测试上。前面说过341可以通过以2为底的Fermat测试，
因为2^340 mod 341=1。如果341真是素数的话，那么2^170 mod 341只可能是1或340；当算得2^170 mod 341
确实等于1时，我们可以继续查看2^85除以341的结果。我们发现，2^85 mod 341=32，这一结果摘掉了341头上的
素数皇冠，面具后面真实的嘴脸显现了出来，想假扮素数和我的素MM交往的企图暴露了出来。



自己的理解：

根据费马小定理，知道，如果p是素数，a是一个小于p的正整数，则a^(p - 1) % p == 1
不妨取a = 2，如果是p是素数，上述结论一定成立，但其逆命题不一定成立，也就是满足
2^(p - 1) % p == 1的p不一定是素数，但其出错的几率不大，所以之后的素数测试还是在
这个基础上改进。

MR的工作：如果p是素数，x是小于p的数，如果x^2 % p == 1,x要么等于1，要么等于p - 1（证明见上面）

MR素数测试可以将费马小定理和MR工作结合起来使用，只有全部满足时才有可能是素数（也有可能是合数
比如2047，进一步优化是让a等与3或。。）

输入一个待测试的数素n, 费马小定理需要验证2 ^ (n - 1) % p 是否等于1，我们可以这样做：
首先 n如果是偶数，则其必然不是素数
此时n-1为偶数，n-1 可以写成 u * 2^t，其中t也就是n-1写成二进制形式，其结尾有多少个0

2^(n - 1)  = 2^(u * 2^t)  = ((2^u)^2)^2...(平方t次)

可以看到(2^u)^2 正好符合MR工作验证素数时的输入，但其要求(2^u)是小于n的数，这个要求在此
可能不会满足，但如果其大于n，其一定是这样的形式：
1 + k*n  或 (n - 1) + k*n
因此我们只需要判断其%n是不是1或n-1

即如果2^(n -1) % n == 1,我们还可以验证2 ^((n - 1) / 2) % n 是不是等于1或n-1
实现时是反过来进行的

poj1811中的代码比较详细

 * */ 

namespace algorithm {
//
// [a ^(n-1)] % n
// n - 1一定是偶数可以表是为 u * 2^t
//
// ==> a^(n - 1) = (a^u)^(2^t)
//     即a^u平方t次
//
//     a^(n - 1) % n  == (a^u % n)^(2^t)
//
bool Prime(int a, int n) {
  int t = 0;
  int u = n - 1;
  while ((u & 1) == 0) {
    t++;
    u >>= 1;
  }
  int pre = PowMod(a, u, n);; // 不能使用系统的可能越界
  for (int i = 0; i < t; i++) {
    int cur = MultiMod(pre, pre, n);  // 可以使用上面的快速方法
    if (cur == 1 && pre != 1 && pre != n - 1) {  // 违反Miller和Rabin的工作
      return false;// 至少会被验证一次，最有一次
    }
    pre = cur;
  }
  return pre == 1 ? true : false;  // 根据费马小定理判定
}

bool PrimeWrapper(int n, int s = 50) {
  if (n == 2) return true;
  if (n % 2 == 0 || n == 1) return false;
  for (int i = 0; i < s; i++) {
    // int a = rand() % (n - 1) + 1;
    int a = rand() * (n - 2) / RAND_MAX + 1;
    // rand()只能随机产生[0, RAND_MAX)内的整数
    // 而且这个RAND_MAX只有32768直接%n的话永远也产生不了
    // [RAND-MAX, n)之间的数
    // 循环尝试不同的底数
    if (Prime(a, n) == false) return false;
  }
  return true;
}

}  // namespace algorithm

using namespace algorithm;

int main(int argc, char** argv) {
  int n = 7;
  LOG(INFO) << n << ":" << PrimeWrapper(n);
  n = 10;
  LOG(INFO) << n << ":" << PrimeWrapper(n);
  return 0;
}
