// Copyright 2013 Jike Inc. All Rights Reserved.
// Author: Liqiang Guo(guoliqiang@jike.com)
// I just want to GH to hss~
// Date  : 2013-10-29 06:02:05
// File  : code.cc
// Brief :

#include "base/public/common_head.h"

namespace algorithm {
/*
 * 小红是个游戏迷，他和小蓝一起玩拿石子游戏。游戏规则为2个人轮流拿石子。一次可以拿1颗或3颗，规定谁取到最后
 * 一颗石子谁就胜出。最后决定由小红先取。两人都是游戏高手，该赢的绝不会输。问在知道石子总数的情况下，怎样快速预测谁将会胜出.
 * 
 * 分析:
   如果某个人取完后剩下4颗石子。这个人一定赢，因为接下来的人，如果取1个，则剩下3个，可以一次取走；如果取3个剩下一个
 * 也可以一次取走。
 * 如果 n % 4 == 1 或 3，先取的人就取这个数字，接下来，如果另一个人取3，就取1，如果另一个人取1就取3，最后总会剩下4个而且是
 * 另一个人先取。
 * 如果 n % 4 == 0 或 2，先取的人必输，因为另一个人可以按照上述方法，剩下4个石子给先取的人。
 *
 * 巴什博奕（Bash Game）
 * 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。   
 * 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。
 * 因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m），那么先取者要拿走s个物品，如果后取者拿走k（≤m）个
 * ，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，
 * 要保持给对手留下（m+1）的倍数，就能最后获胜。   
 * 
 * ***这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜
 *
 * */

/*
 * Fibonacci Nim (斐波那契取石子博弈)
 * 有一堆个数为n的石子，游戏双方轮流取石子，满足：
 * 1)先手不能在第一次把所有的石子取完；
 * 2)之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。
 * 约定取走最后一个石子的人为赢家.
 *
 *
 * 分析：
(1). 当n为Fibonacci数的时候，先取者必败。
用第二数学归纳法证明：
为了方便，将n记为f[i]。
  1、当i=2时，先手只能取1颗，显然必败，结论成立。
  2、假设当i<=k时，结论成立。
     则当i=k+1时，f[i] = f[k]+f[k-1]。
     则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。
     （一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]，则后手可以直接取完f[k]，因为f[k] < 2*f[k-1]）
     对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。
     如果先手第一次取的石子数y>=f[k-1]/3，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时x=f[k-1]-y，则x<=2/3*f[k-1]。
     我们来比较一下2/3*f[k-1]与1/2*f[k]的大小。即4*f[k-1]与3*f[k]的大小，对两值作差后:
     4 * f[k - 1] - 3* f[k] = 4f[k-1] - 3f[k-1] - 3f[k - 2] = f[k - 1] - 3f[k - 2] < 0
     ==> 2/3*f[k - 1] < 1/2*f[k]
     得到，x<1/2*f[k]。
     即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗，所以后手必胜。
     即i=k+1时，结论依然成立。

(2) 当n为非Fibonacci数的时候，可以保证先取着必胜。

齐肯多夫定理：任何正整数可以表示为若干个不连续的Fibonacci数之和。
证明：基于数学归纳法 http://www.cis.umac.mo/~fstitl/2000-topics/fibonacci.html
                     http://blog.sina.com.cn/s/blog_6842b59101017sx7.html

n = f[a1] + f[a2] + ... + f[an]
其中 a1 > a2 > ... > an 且 ak > ak + 1 (即不连续Fibonacci数)

令先手先取完f[an]，即最小的这一堆。由于各个f之间不连续，则有f[a(n-1)] > 2*f[an]。
即后手只能取f[a(n-1)]这一堆，且不能一次取完。
此时后手相当于面临这个子游戏（只有f[a(n-1)]这一堆石子，且后手先取）的必败态，
即先手一定可以取到这一堆的最后一颗石子。
同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。

 * */

bool Fibonnaci(int n) {  // n > 1
  if (n == 2 || n == 3) return false;
  int p1 = 2;
  int p2 = 3;
  while (n > p2) {
    int t = p2;
    p2 += p1;
    p1 = t;
  }
  return n == p2 ? false : true;
}

/*
威佐夫博奕（Wythoff Game）
http://blog.csdn.net/mdj67887500/article/details/2829898
问题描述：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，...,n)表示两堆物品的数量并称其为局势，如果甲面对(0,0)，
那么甲已经输了，这种局势我们称为奇异局势。
前几个奇异局势是：
（0，0）
（1，2）
（3，5）
（4，7）
（6，10）
（8，13）
（9，15）
（11，18）
（12，20）
可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而bk= ak+k，奇异局势有如下三条性质：
1、任何自然数都包含在一个且仅有一个奇异局势中。
由于ak是未在前面出现过的最小自然数，所以有ak>ak-1，而bk= ak+k> ak-1+(k-1)=bk-1>ak-1。所以性质1成立。

2、任意操作都可将奇异局势变为非奇异局势。
事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。

3、采用适当的方法，可以将非奇异局势变为奇异局势。
假设面对的局势是(a,b)，分以下几种情况讨论：
1) 若b=a，则同时从两堆中取走a 个物体，就变为了奇异局势（0，0）；
2) 若a=ak ，b >bk，那么，从第二堆中取走b- bk个物体，即变为奇异局势(ak,bk)；
3) 若a=ak ，b < bk,则同时从两堆中拿走a-a(b-a)个物体,变为奇异局势(a(b- a) , b(b -a))；
4) 若a>ak ，b = ak + k,则从第一堆中拿走多余的数量a -ak即可；
5) 若a<ak ，b = ak + k,分两种情况：
    (1) a=aj （j < k）时，从第二堆里面拿走b-bj即可，变为(aj , bj)；
    (2) a=bj （j < k）时，从第二堆里面拿走b-aj即可，变为(bj , aj)。
注意：a!=ak且b!=bk 的情况不存在，因为由a或b的值肯定能确定一种奇异局势，即要么a=ak,要么b=bk。


从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。

那么任给一个局势(a，b）(a<b)，怎样判断它是不是奇异局势呢？我们有如下公式：
ak =[k(1+√5)/2]，bk= ak + k （k=0，1，2，...,n 方括号表示取整函数）
奇妙的是其中出现了黄金分割数（1+√5）/2 = 1.618...,因此,由ak，bk 组成的矩形近似为黄金矩形，由于2/(1+√5)=(√5-1)/2，
可以先确定这是第几个局势。设该局势是第j个局势，那么j=[a(√5-1)/2]，此时这个奇异局势有2种可能：
1)若a=[j(1+√5)/2]，那么a = aj，若同时有b= aj + j，则奇异局势为(aj,bj)；
2)若a!=[j(1+√5)/2]，那么有可能是a = aj+1，此时如果又有b = aj+1+(j + 1)，则奇异局势为(aj+1,bj+1)。
若以上两种情况都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。
*/
bool Wythoff(int a, int b) {
  double key = (sqrt(5) + 1) / 2;
  if (a > b) std::swap(a, b);
  int k = b - a;
  return a == floor(k * key) ? false : true;
}

/* http://www.wutianqi.com/?p=1081
 * 尼姆博奕（Nimm Game）
 * 有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
 * 
 * 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。
 * 第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。
 * 仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。
 *
 * 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号 xor 表示这种运算。这种运算和一般加法不同的一点是1 xor 1=0。
 * 先看（1，2，3）的按位模2加的结果：
  1 = 二进制01
  2 = 二进制10
  3 = 二进制11  xor
  ———————
  0 = 二进制00 （注意不进位）
  对于奇异局势（0，n，n）也一样，结果也是0。
  任何奇异局势（a，b，c）都有a xor b xor c =0。
  如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？
  假设 a < b< c,我们只要将 c 变为 a xor b,即可,因为有如下的运算结果: 
  a xor b xor (a xor b) = (a xor a) xor (b xor b) = 0 xor 0=0。要将c 变为a xor b，只要从 c中减去 c-（a xor b）即可。
  
  例1。（14，21，39），14 xor 21=27，39-27=12，所以从39中拿走12个物体即可达到奇异局势（14，21，27）。
  例2。（55，81，121），55 xor 81=102，121-102=19，所以从121中拿走19个物品就形成了奇异局势（55，81，102）。
  例3。（29，45，58），29 xor 45=48，58-48=10，从58中拿走10个，变为（29，45，48）。
  例4。我们来实际进行一盘比赛看看：
        甲:(7,8,9)->(1,8,9)奇异局势
        乙:(1,8,9)->(1,8,4)
        甲:(1,8,4)->(1,5,4)奇异局势
        乙:(1,5,4)->(1,4,4)
        甲:(1,4,4)->(0,4,4)奇异局势
        乙:(0,4,4)->(0,4,2)
        甲:(0.4,2)->(0,2,2)奇异局势
        乙:(0,2,2)->(0,2,1)
        甲:(0,2,1)->(0,1,1)奇异局势
        乙:(0,1,1)->(0,1,0)
        甲:(0,1,0)->(0,0,0)奇异局势
        甲胜。

题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，  
可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法.

定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则，  
为利己态，用S表示。
[定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。
证明：
    若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，
       c = A(1) xor A(2) xor … xor A(n) > 0;
    把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。
    那么我们把x = A(t) xor c,则得到x < A(t).这是因为既然A(t)的第p位与c的第p位同为1,那么x的第p位变为0,而高于p的位并没有改变。所以x < A(t).而
     A(1) xor A(2) xor … xor x xor … xor A(n)
   = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)
   = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)
   = 0
这就是说从A(t)堆中取出 A(t) - x 根火柴后状态就会从S态变为T态。证毕
[定理2]：T态，取任何一堆的若干根，都将成为S态。
证明：用反证法试试。
      若
       c = A(1) xor A(2) xor … xor A(i) xor … xor A(n) = 0；
       c' = A(1) xor A(2) xor … xor A(i') xor c xor … xor A(n) = 0;
      则有
c xor c' = A(1) xor A(2) xor … xor A(i) xor … xor A(n) xor A(1) xor A(2) xor … xor A(i') xor c xor … xor A(n) = A(i) xor A(i') =0
      进而推出A(i) = A(i')，这与已知矛盾。所以命题得证。

[定理 3]：S态，只要方法正确，必赢。  
   最终胜利即由S态转变为T态，任何一个S态，只要把它变为T态，（由定理1，可以把它变成T态。）对方只能把T态转变为S态(定理2)。这样，所有S态向T态的转变都可以有己方控制，对方只能被动地实现由T态转变为S态。故S态必赢。

[定理4]：T态，只要对方法正确，必败。  
   由定理3易得。  


题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，  
可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。
定义：若一堆中仅有1根火柴，则被称为孤单堆。若大于1根，则称为充裕堆。
定义：T态中，若充裕堆的堆数大于等于2，则称为完全利他态，用T2表示；若充裕堆的堆数等于0，则称为部分利他态，用T0表示。
      T1表示只有一个充裕堆,但这个状态不可能存在，当充裕堆只有一个时，其不可能是T态
定义：S态中，若充裕堆的堆数大于等于2，则称为完全利己态，用S2表示；若充裕堆的堆数等于0，则称为部分利己态，用S0表示。
      S1表示只有一个充裕堆

[定理5]：S0态，即仅有奇数个孤单堆，必败。T0态必胜。 
证明：
S0态，其实就是每次只能取一根。每次第奇数根都由己取，第偶数根都由对 
方取，所以最后一根必己取。败。同理,  T0态必胜

[定理6]：S1态，只要方法正确，必胜。 
证明：
此时有一对充裕堆，若孤单堆堆数为奇数，把充裕堆取完；否则，将充裕堆取成一根。
这样，就变成奇数个孤单堆，由对方取。由定理5，对方必输。己必胜.
[定理7]：S2态不可转一次变为T0态。 
证明：
充裕堆数不可能一次由2变为0.

[定理8]：S2态可一次转变为T2态。 
证明：
由定理1，S态可转变为T态，S态可一次转变为T态，又由定理6，S2态不可转一次变为T0态，所以转变的T态为T2态。
[定理9]：T2态，只能转变为S2态或S1态。 
证明：
由定理2，T态必然变为S态。由于充裕堆数不可能一次由2变为0，所以此时的S态不可能为S0态。

[定理10]：S2态，只要方法正确，必胜. 
证明：
方法如下： 
      1）  S2态，就把它变为T2态。（由定理8） 
      2）  对方只能T2转变成S2态或S1态（定理9）
    若转变为S2,  转向1） 
    若转变为S1,  这己必胜。（定理5）
[定理11]：T2态必输。 
证明：1) 无论如何取都会编程S1态或S2态 （定理9）
      2）此时对方必胜（定理10， 定理6）

综上所述，必输态有：  T2,S0 
          必胜态：    S2,S1,T0. 
 
抢夺S1是制胜的关键！ 
为此，始终把T2态让给对方，将使对方处于被动状态，他早晚将把状态变为S1.
 * */

}  // namespace algorithm

using namespace algorithm;


int main(int argc, char** argv) {

  return 0;
}
