// Copyright 2014 Liqiang Guo. All Rights Reserved.
// Author: Liqiang Guo (guoliqiang2006@gmail.com)
// I just want to GH to hss~
// Date  : 2014-01-13 18:44:30
// File  : code.cc
// Brief :

#include "base/public/common_ojhead.h"

// TLE
// poj1204
namespace algorithm {
const int MAXN = 1010;
int M;
int N;
int W;

struct RNode {
  int row;
  int col;
  char ch;
  RNode(int r = 0, int co = 0, char c = ' ') : row(r), col(co), ch(c) {}
};

std::vector<std::string> words;
std::map<std::string, RNode> rs;
std::vector<std::string> matrix;

struct Node {
  char ch;
  Node * failure;
  std::map<char, Node *> child;  // can improve
  std::string value;
  Node(char c) : ch(c), failure(NULL) {
    value.clear();
    child.clear();
  }
};

Node * ac_root = NULL;

void Build(Node * root, const std::string & str, int k) {
  if (k == str.size()) {
    root->value = str;
  } else {
    if (!(root->child.count(str[k]))) root->child[str[k]] = new Node(str[k]);
    Build(root->child[str[k]], str, k + 1);
  }
}

void Failure() {
  std::queue<Node *> queue;
  queue.push(ac_root);
  while (!queue.empty()) {
    Node * t = queue.front();
    queue.pop();
    for (std::map<char, Node*>::iterator i = t->child.begin(); i != t->child.end(); i++) {
      if (t == ac_root) {
        i->second->failure = ac_root;
      } else {
        Node * tmp = t->failure;
        while (tmp != NULL && !(tmp->child.count(i->first))) {
          tmp = tmp->failure;
        }
        if (tmp == NULL) {
          i->second->failure = ac_root;
        } else {
          i->second->failure = tmp->child[i->first];
        }
      }
      queue.push(i->second);
    }
  }
}

void Build() {
  ac_root = new Node(' ');
  for (int i = 0; i < words.size(); i++) {
    Build(ac_root, words[i], 0);
  }
  ac_root->failure = NULL;
  Failure();
}

void Next(int & x, int &y, int ch) {
  if (ch == 'A' || ch == 'B' || ch == 'H') {
    x -= 1;
  }
  if (ch == 'F' || ch == 'E' || ch == 'D') {
    x += 1;
  }
  if (ch == 'H' || ch == 'G' || ch == 'F') {
    y -= 1;
  }
  if (ch == 'B' || ch == 'C' || ch == 'D') {
    y += 1;
  }
}

void Save(int x, int y, char ch, Node * root) {
  if (root->value.size() != 0) {
    if (!rs.count(root->value)) {
      int row, col;
      if (ch == 'A') {
        row = x + root->value.size() - 1;
        col = y;
      }
      if (ch == 'B') {
        row = x + root->value.size() - 1;
        col = y - root->value.size() + 1;
      }
      if (ch == 'C') {
        row = x;
        col = y - root->value.size() + 1;
      }
      if (ch == 'D') {
        row = x - root->value.size() + 1;
        col = y - root->value.size() + 1;
      }
      if (ch == 'E') {
        row = x - root->value.size() + 1;
        col = y;
      }
      if (ch == 'F') {
        row = x - root->value.size() + 1;
        col = y + root->value.size() - 1;
      }
      if (ch == 'G') {
        row = x;
        col = y + root->value.size() - 1;
      }
      if (ch == 'H') {
        row = x + root->value.size() - 1;
        col = y + root->value.size() - 1;
      }
      rs[root->value] = RNode(row, col, ch);
    }
  }
}

void Match(Node * root, int x, int y, char ch) {
  while (true) {
    if (x < 0 || x >= M || y < 0 || y >= N) return;
    while (root != ac_root && !(root->child.count(matrix[x][y]))) {
      root = root->failure;
    }
    if (root->child.count(matrix[x][y])) {
      root = root->child[matrix[x][y]];
    }
    Node * t = root;
    while (t != ac_root) {
      Save(x, y, ch, t);
      t = t->failure;
    }
    Next(x, y, ch);
  }
}

void Solve() {
  for (int i = 0; i < M; i++) {
    Match(ac_root, i, 0, 'C');
    Match(ac_root, i, N - 1, 'G');
  }
  for (int i = 0; i < N; i++) {
    Match(ac_root, 0, i, 'E');
    Match(ac_root, M - 1, i, 'A');
  }
  for (int i = 0; i < M; i++) {
    Match(ac_root, i, 0, 'B');
    Match(ac_root, i, N - 1, 'F');
  }
  for (int i = 0; i < N; i++) {
    Match(ac_root, M - 1, i, 'B');
    Match(ac_root, 0, i, 'F');
  }
  for (int i = N - 1; i >= 0; i--) {
    Match(ac_root, 0, i, 'D');
    Match(ac_root, M - 1, i, 'H');
  }
  for (int i = 0; i < M; i++) {
    Match(ac_root, i, 0, 'D');
    Match(ac_root, i, N - 1, 'H');
  }
}

void Read() {
  char tmp[1010];
  while (scanf("%d%d%d", &M, &N, &W) != EOF) {
    matrix.clear();
    words.clear();
    rs.clear();
    getchar();
    for (int i = 0; i < M; i++) {
      scanf("%s", tmp);
      getchar();
      matrix.push_back(std::string(tmp));
    }
    for (int i = 0; i < W; i++) {
      scanf("%s", tmp);
      getchar();
      words.push_back(std::string(tmp));
    }
    Build();
    Solve();
    for (int i = 0; i < W; i++) {
      RNode & t = rs[words[i]];
      printf("%d %d %c\n", t.row, t.col, t.ch);
    }
  }
}
}  // namespace algorithm

using namespace algorithm;

int main(int argc, char** argv) {
  FROMFILE;
  Read();
  return 0;
}
