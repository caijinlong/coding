// Copyright 2013 Jike Inc. All Rights Reserved.
// Author: Liqiang Guo(guoliqiang@jike.com)
// I just want to GH to hss~
// Date  : 2013-11-07 00:55:13
// File  : code.cc
// Brief :

/*
 * WA
 * */

#include "base/public/common_ojhead.h"


namespace algorithm {
#define INF 0x3f3f3f3f
const int MAX = 105;
int N = 0;
double matrix[MAX][MAX];
float coor[MAX][2];

int to[MAX];
double dis[MAX];
int tag[MAX];
int root[MAX];

float rs = 0;

float Distance(int x, int y) {
  float t = (coor[x][0] - coor[y][0]) * (coor[x][0] - coor[y][0]) +
          (coor[x][1] - coor[y][1]) * (coor[x][1] - coor[y][1]);
  return sqrt(t);
}

int Root(int k) {
  if (root[k] == k) return k;
  return root[k] = Root(root[k]);
}


int ZhuLiu(int r) {
  memset(tag, -1, sizeof(tag));
  memset(to, -1, sizeof(to));
  for (int i = 1; i <= N; i++) dis[i] = INF;
  for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= N; j++) {
      int u = Root(i);
      int v = Root(j);
      if (u != v && matrix[i][j] < dis[v]) {
        dis[v] = matrix[i][j];
        to[v] = u;
      }
    }
  }
  dis[r] = 0;
  to[r] = -1;
  tag[r] = r;
  bool circle = false;
  for (int i = 1; i <= N; i++) {
    if (root[i] != i || tag[i] != -1) continue;
    int j = i;
    for (j = i; j != - 1 && tag[j] == -1; j = to[j]) tag[j] = i;
    if (j == -1) return -1;
    if (tag[j] == i) {
      circle = true;
      tag[j] = -2;
      for (int k = to[j]; k != j; k = to[k]) tag[k] = -2;
    }
  }
  if (circle) {
    for (int i = 1; i <= N; i++) {
      for (int j = 1; j <= N; j++) {
        int u = Root(i);
        int v = Root(j);
        if (u != v && tag[v] == -2 && matrix[i][j] != INF)  matrix[i][j] -= dis[v];
      }
    }
    for (int i = 1; i <= N; i++) {
      if (tag[i] == -2) {
        tag[i] = -1;
        rs += dis[i];
        for (int j = to[i]; j != i; j = to[j]) {
          root[j] = i;
          tag[j] = -1;
          rs += dis[j];
        }
      }
    }
    if (ZhuLiu(r) == -1) return -1;
  } else {
    for (int i = 1; i <= N; i++) {
      if (root[i] == i) rs += dis[i];
    }
  }
  return 0;
}

double ZL(int r) {
  rs = 0;
  memset(root, 0, sizeof(root));
  for (int i = 1; i <= N; i++) root[i] = i;
  if (ZhuLiu(r) == -1) return -1;
  else return rs;
}

void Read() {
  int n = 0;
  int m = 0;
  while (scanf("%d%d", &n, &m) != EOF) {
    N = n;
    getchar();
    for (int i = 0; i < MAX; i++) {
      for (int j = 0; j < MAX; j++) matrix[i][j] = INF;
    }
    memset(coor, 0, sizeof(coor));
    for (int i = 0; i < n; i++) {
      float x, y;
      scanf("%f%f", &x, &y);
      coor[i + 1][0] = x;
      coor[i + 1][1] = y;
      getchar();
    }
    for (int i = 0; i < m; i++) {
      int u, v;
      scanf("%d%d", &u, &v);
      if (u != v) matrix[u][v] = Distance(u, v);
      getchar();
    }
    float t = ZL(1);
    if (t < 0) printf("poor snoopy\n");
    else printf("%.2lf\n", t);
  }
}

}  // namespace algorithm

using namespace algorithm;


int main(int argc, char** argv) {
  FROMFILE;
  Read();
  return 0;
}
