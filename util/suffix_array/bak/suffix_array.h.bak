// Copyright 2013 Jike Inc. All Rights Reserved.
// Author: Liqiang Guo(guoliqiang@jike.com)
// I just want to GH to hss~
// Date  : 2013-09-12 23:58:38
// File  : suffix_array.h
// Brief :
// http://www.nocow.cn/index.php/%E5%90%8E%E7%BC%80%E6%95%B0%E7%B
// B%84#.E5.90.8E.E7.BC.80.E6.95.B0.E7.BB.84.E7.9A.84.E5.BA.94.E7.94.A8

#ifndef  __SUFFIX_ARRAY_H_
#define  __SUFFIX_ARRAY_H_

#include <vector>
#include <iostream>
#include "base/public/logging.h"
#include "base/public/shared_ptr.h"
#include "base/public/scoped_ptr.h"
#include "base/public/string_util.h"
#include "math.h"

namespace util {

class SuffixArray {
 public:
  SuffixArray(std::string & str) : str_(str){
    rank_.reset(new std::vector<int>(str.size() * 2, 0));
    sa_.reset(new std::vector<int>(str.size() + 1, 0));
    height_.reset(new std::vector<int>(str.size() + 1, 0));
    sum_.reset(new int[0xFF]);
    int foo = pow(2, log(str.size()) / log(2) + 1);
    rmq_.reset(new int[foo]);
    rmq_fast_.reset(new std::vector<base::shared_ptr<int> >());
    for (int i = 0; i < str_.size(); i++) {
      base::shared_ptr<int> bar(new int[str_.size()]);
      rmq_fast_.get()->push_back(bar);
      memset(bar.get(), 0, sizeof(int) * str.size());
    }
    // building
    Build();
  }

 public:
  base::shared_ptr<std::vector<int> > get_rank() {
    return rank_;
  }
 
  base::shared_ptr<std::vector<int> > get_sa() {
    return sa_;
  }

  base::shared_ptr<std::vector<int> > get_height() {
    return height_;
  }

  int GetRMQ(int b, int e);
  int GetRMQFast(int b, int e);

 private:
  int GetRMQInternal(int b, int e, int i, int j, int index);
  void Build();
  void Height();
  void BucketSort(int j);
  void RMQ(int index, int b, int e);
  void RMQFast();
 // only used for unittest
 public:
  void OutRank() {
    for (int i = 0; i < str_.size(); i++) {
      std::cout << "rank[" << i << "] : " << (*rank_)[i] << " ";
    }
    std::cout << std::endl;
  }
  void OutSa() {
    for (int i = 1; i <= str_.size(); i++) {
      std::cout << "sa[" << i << "] : " << (*sa_)[i] << " ";
    }
    std::cout << std::endl;
  }
  void OutHeight() {
    for (int i = 0; i < str_.size(); i++) {
      std::cout << "height[" << i << "] : " << (*height_)[i] << " ";
    }
    std::cout << std::endl;
  }
 
 private:
  std::string str_;
  base::shared_ptr<int> sum_;
  base::shared_ptr<int> rmq_;
  base::shared_ptr<std::vector<base::shared_ptr<int> > > rmq_fast_;
 
 private:
  base::shared_ptr<std::vector<int> > rank_;
  base::shared_ptr<std::vector<int> > sa_;
  base::shared_ptr<std::vector<int> > height_;
  // LCP (longest common prefix) array
};

void SuffixArray::BucketSort(int j) {
  int size = str_.size();
  scoped_ptr<int> tsa(new int[size]);
  memset(tsa.get(), 0, size * sizeof(int));
  memset(sum_.get(), 0, 0xFF * sizeof(int));

  for (int i = 0; i < size; i++) {
    sum_.get()[(*rank_.get())[i + j]]++;
  }
  for (int i = 1; i < 0xFF; i++) {
    sum_.get()[i] += sum_.get()[i - 1];
  }
  // sort using the second key
  for (int i = size - 1; i >= 0; i--) {
    tsa.get()[sum_.get()[(*rank_)[i + j]]--] = i;
  }
  for (int i = 0; i < size; i++) {
    std::cout << "tsa[" << i << "] : " << tsa.get()[i] << " ";
  }
  std::cout << std::endl;
 
  memset(sum_.get(), 0, 0xFF * sizeof(int));
  for (int i = 0; i < size; i++) {
    sum_.get()[(*rank_)[i]]++;
  }
  for (int i = 1; i < 0xFF; i++) {
    sum_.get()[i] += sum_.get()[i - 1];
  }
  // sort using the first key
  for (int i = size - 1; i > 0; i--) {
    (*sa_)[--sum_.get()[(*rank_)[tsa.get()[i]]]] = tsa.get()[i];
  }
}

void SuffixArray::Build() {
  scoped_ptr<char> trank(new char[str_.size()]);
  int size = str_.size();

  for (int i = 0; i< size; i++) {
    trank.get()[i]= str_[i];
  }
  for (int i = 0; i < size; i++) {
    sum_.get()[static_cast<int>(trank.get()[i])]++;
  }
  for (int i = 1; i < 0xFF; i++) {
    sum_.get()[i] += sum_.get()[i - 1];
  }
  
  /*
  for (int i = 0; i < size; i++) {
    LOG(INFO) << static_cast<int>(trank.get()[i]) << " "
              << sum_.get()[static_cast<int>(trank.get()[i])];
  }
  */
  // sa index : 1 ~ size  value : 0 ~ size-1
  // rank index : 0 ~ size - 1 value : 0 ~ size
  for (int i = size - 1; i >= 0; i--) {
    (*sa_)[sum_.get()[static_cast<int>(trank.get()[i])]--] = i;
  }
  LOG(INFO) << "first sa:";
  OutSa();
  
  // build first rank and sa
  // at begin rank may have same values.
  (*rank_)[(*sa_)[1]] = 1;
  int p = 1;
  for (int i = 2; i < size; i++) {
    if (trank.get()[(*sa_)[i]] != trank.get()[(*sa_)[i - 1]]) p++;
    (*rank_)[(*sa_)[i]] = p;
  }

  LOG(INFO) << "first rank:";
  OutRank();
  
  for (int j = 1; j < size; j *= 2) {
    BucketSort(j);
    trank.get()[(*sa_)[1]] = 1;
    p = 1;
    for (int i = 2; i < size; i++) {
      if (((*rank_)[(*sa_)[i]] != (*rank_)[(*sa_)[i-1]]) ||
          ((*rank_)[(*sa_)[i] + j ] != (*rank_)[(*sa_)[i - 1] + j])) {
        p++;
      }
      trank.get()[(*sa_)[i]] = p;
    }
    for (int i = 1; i < size; i++) {
      (*rank_)[i] = trank.get()[i];
    }
  }

  Height();
  RMQ(0, 0, str_.size() - 1);
  RMQFast();
}

// height[i] >= height[i - 1] -1 (i is the subscript of string:, 1,2...)
// "abcdf"
//  height[cdf] >= height[bcdf] + 1
//  Proof:
//

void SuffixArray::Height() {
  int j = 0;
  for (int i = 0; i <= str_.size(); i++) {
    if ((*rank_)[i] == 0) continue;
    while (str_[i + j - 1] ==
           str_[(*sa_)[(*rank_)[i] - 1] + j - 1]) {
      j++;
    }
    (*height_)[(*rank_)[i]] = j;
    if (j > 0) j--;
  }
}

void SuffixArray::RMQ(int index, int b, int e) {
  if (b == e) {
    rmq_.get()[index] = (*height_)[(*rank_)[b]];
  } else {
    int mid = b + (e - b) / 2;
    RMQ(2 * index + 1, b, mid); // [b, mid]
    RMQ(2 * index + 2, mid + 1, e);  // [mid + 1, e]
    if (rmq_.get()[2 * index + 1] < rmq_.get()[2 * index + 2]) {
      rmq_.get()[index] = rmq_.get()[2 * index + 1];
    } else {
      rmq_.get()[index] = rmq_.get()[2 * index + 2];
    }
  }
}

int SuffixArray::GetRMQ(int b, int e) {
  return GetRMQInternal(b, e, 0, str_.size() - 1, 0);
}

int SuffixArray::GetRMQInternal(int b, int e, int i, int j, int index) {
  if (b == i && e == j) return rmq_.get()[index];
  int mid = i + (j - i) / 2;
  if (e <= mid) {
    return GetRMQInternal(b, e, i, mid, 2 * index + 1);
  }
  if (b > mid) {
    return GetRMQInternal(b, e, mid + 1, j, 2 * index + 2);
  }
  int foo = GetRMQInternal(b, mid, i, mid, 2 * index + 1);
  int bar = GetRMQInternal(b, mid + 1, mid + 1, j, 2 * index + 2);
  return foo < bar ? foo : bar;
}

int SuffixArray::GetRMQFast(int b, int e) {
  CHECK_LE(b, e);
  return (*rmq_fast_.get())[b].get()[e];
}

void SuffixArray::RMQFast() {
  for (int i = 0; i< str_.size(); i++) {
    (*rmq_fast_.get())[i].get()[i] = (*height_)[(*rank_)[i]];
  };
  for (int i = 1; i < str_.size(); i++) {
    for (int j = 0; j < str_.size() - i; j++) {
      int min = (*rmq_fast_.get())[j].get()[j] + (*rmq_fast_.get())[j + 1].get()[j + i];
      for (int k = j + 1; k < j + i; k++) {
        if (min < (*rmq_fast_.get())[j].get()[k] + (*rmq_fast_.get())[k + 1].get()[j + i]) {
          min = (*rmq_fast_.get())[j].get()[k] + (*rmq_fast_.get())[k + 1].get()[j + i];
        }
      }
      (*rmq_fast_.get())[j].get()[j + i] = min;
    }
  }
}

}  // namespace util

#endif  //  __SUFFIX_ARRAY_H_
